import logging
from pathlib import Path
from enum import StrEnum
from dataclasses import dataclass
import datetime
from typing import Any, Self, NewType
from collections.abc import Iterable
from collections.abc import Collection
import asyncio
import aiohttp
import tomllib

from potlib.error import (
    ModNotDefined,
    ModAlreadyDefined,
    ModMissingField,
    ModInvalidKind,
    ModFieldInvalid,
    DuplicateModWorkshopID,
    DuplicateModPath,
)

logger = logging.getLogger('potlib.arma')

# A mapping of all mods by their name.
# An entry is created when a mod is loaded from a mod definition file
MODS: dict[str, 'Mod'] = {}

# A mapping of all modlists by their name.
# An entry is created when a modlist is initialised
MODLISTS: dict[str, 'Modlist'] = {}

WorkshopId = NewType('WorkshopId', int)


@dataclass
class SteamWorkshopDetails:
    workshop_id: WorkshopId
    title: str
    file_size_bytes: int
    last_update: datetime.datetime

    @classmethod
    def from_json(cls, json: dict[str, Any]) -> Self:
        """
        ### Create a SteamWorkshopDetails instance from JSON data

        *Docstring generated by AI.*

        Parses the provided JSON dictionary to create a SteamWorkshopDetails object.
        Extracts workshop ID, title, file size, and last update timestamp from the
        Steam API response format.

        **Async:** No

        **Args:**
        - `json` (`dict[str, Any]`): The JSON data containing workshop details from Steam API.

        **Returns:**
        - `SteamWorkshopDetails`: An instance populated with the data from the JSON.

        **Example:**
        ```python
        details = SteamWorkshopDetails.from_json({
            'publishedfileid': '463939057',
            'title': 'ACE3',
            'file_size': 1024000,
            'time_updated': 1640995200
        })
        # SteamWorkshopDetails(workshop_id=463939057, title='ACE3', ...)
        ```
        """
        return cls(
            workshop_id=WorkshopId(json.get('publishedfileid', -1)),
            title=json.get('title', 'Unknown Title'),
            file_size_bytes=json.get('file_size', 0),
            last_update=datetime.datetime.fromtimestamp(json.get('time_updated', 0)),
        )


async def fetch_mod_details_from_workshop(mods: Collection['Mod']) -> dict[WorkshopId, SteamWorkshopDetails]:
    """
    ### Fetch mod details from Steam Workshop API

    *Docstring generated by AI.*

    Makes an asynchronous HTTP request to the Steam Workshop API to retrieve detailed
    information about mods based on their workshop IDs. Returns a dictionary mapping
    workshop IDs to their corresponding SteamWorkshopDetails objects. Handles API
    errors gracefully by logging warnings and returning an empty dictionary if the
    request fails completely.

    **Async:** Yes

    **Args:**
    - `mods` (`Collection['Mod']`): A collection of Mod objects containing workshop IDs to fetch details for.

    **Returns:**
    - `dict[WorkshopId, SteamWorkshopDetails]`: A dictionary mapping workshop IDs to their Steam Workshop details.

    **Example:**
    ```python
    details = await fetch_mod_details_from_workshop([ace_mod, cba_mod])
    # {WorkshopId(463939057): SteamWorkshopDetails(...), WorkshopId(450814997): SteamWorkshopDetails(...)}
    ```
    """
    mod_workshop_ids = {mod.workshop_id: mod.name for mod in mods if not mod.manual_install}

    request_url = 'http://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/v1/'
    params: dict[str, Any] = {
        'itemcount': len(mods),
        **{f'publishedfileids[{idx}]': mod.workshop_id for idx, mod in enumerate(mods)},
    }

    # Get mods name form Steam Workshop
    url = request_url
    logger.info('Fetching mod names from Steam Workshop')
    logger.debug(f'Using URL: {url}')

    details: dict[str, SteamWorkshopDetails] = {}
    async with aiohttp.ClientSession() as session:
        async with session.post(url, params=params, data=params) as response:
            if response.status != 200:
                logger.error(f'Failed to fetch mod names ({response.status} {response.reason})')
                return {}
            if response.content_type != 'application/json':
                logger.error(f'Unexpected content type trying to fetch mod names: {response.content_type}')
                return {}

            json = await response.json()
            for file in json['response']['publishedfiledetails']:
                workshop_id = WorkshopId(file['publishedfileid'])
                if 'result' not in file or file['result'] != 1:
                    error_reason = file.get('reason', 'unknown')
                    logger.warning(
                        f'Failed to fetch details for "{mod_workshop_ids[workshop_id]}" ({workshop_id}): {error_reason}'
                    )
                    continue
                if workshop_id not in mod_workshop_ids:
                    logger.warning(f'Workshop ID {workshop_id} not found in loaded mods')
                    continue
                details[workshop_id] = SteamWorkshopDetails.from_json(file)

    return details


def load_mods(mods_file: Path):
    """
    ### Load mod definitions from a TOML configuration file

    *Docstring generated by AI.*

    Parses a TOML configuration file to load mod definitions into the global MODS dictionary.
    Validates all required fields, checks for duplicate workshop IDs and filenames, and fetches
    mod names from the Steam Workshop API. Creates Mod objects with proper directory paths
    based on mod type (regular mod or server mod) and configuration overrides.

    **Async:** No

    **Args:**
    - `mods_file` (`Path`): The path to the TOML file containing mod definitions.

    **Raises:**
    - `ModMissingField`: If required fields are missing from the configuration.
    - `ModFieldInvalid`: If field values have invalid types or formats.
    - `ModAlreadyDefined`: If a mod with the same name is already loaded.
    - `DuplicateModWorkshopID`: If multiple mods share the same workshop ID.
    - `DuplicateModPath`: If multiple mods share the same filename.
    - `ModInvalidKind`: If the mod kind is not a valid Kind enum value.

    **Returns:**
    - `None`: This function modifies the global MODS dictionary and does not return a value.

    **Example:**
    ```python
    load_mods(Path('config/mods.toml'))
    # None
    ```

    Example TOML file:
    ```
        [defaults]
        mod_directory = "/path/to/mods"
        server_mod_directory = "/path/to/server/mods"

        [mod]
        [mod.ace]
        filename = "ace"
        workshop_id = 463939057
        kind = "mod"

        [mod.acre2]
        filename = "acre2"
        workshop_id = 751965892
        manual_install = true

        [mod.cba_a3]
        filename = "cba_a3"
        workshop_id = 450814997
        kind = "server_mod"
        server_mod_directory = "/custom/server/path"

        [mod.custom_mod]
        filename = "custom_mod"
        workshop_id = 123456789
        mod_directory = "/custom/mod/path"
    ```
    """
    mods_added: dict[str, Mod] = {}
    mod_workshop_ids = {mod.workshop_id: mod.name for mod in MODS.values()}
    mod_filenames = {mod.filename: mod.name for mod in MODS.values()}

    with open(mods_file, 'rb') as f:
        config = tomllib.load(f)

    if 'defaults' not in config:
        raise ModMissingField('global', 'defaults')
    if not isinstance(config['defaults'], dict):
        raise ModFieldInvalid('global', 'defaults', 'must be a dictionary')
    if 'mod' not in config:
        raise ModMissingField('global', 'mod')
    if not isinstance(config['mod'], dict):
        raise ModFieldInvalid('global', 'mod', 'must be a dictionary')

    defaults = config['defaults']
    if 'mod_directory' not in defaults:
        raise ModMissingField('defaults', 'mod_directory')
    if not isinstance(defaults['mod_directory'], str):
        raise ModFieldInvalid('defaults', 'mod_directory', 'must be a string')
    if 'server_mod_directory' not in defaults:
        raise ModMissingField('defaults', 'server_mod_directory')
    if not isinstance(defaults['server_mod_directory'], str):
        raise ModFieldInvalid('defaults', 'server_mod_directory', 'must be a string')

    mod_list: dict[str, Any] = config['mod']

    for mod_name, mod_data in mod_list.items():
        # Check if mod already exists
        mod_name = mod_name.replace('-', ' ').strip()
        if mod_name in MODS:
            raise ModAlreadyDefined(mod_name)

        # Check required fields
        if 'filename' not in mod_data:
            raise ModMissingField(mod_name, 'filename')
        if not isinstance(mod_data['filename'], str):
            raise ModFieldInvalid(mod_name, 'filename', 'must be a string')

        if 'workshop_id' not in mod_data:
            raise ModMissingField(mod_name, 'workshop_id')
        if not isinstance(mod_data['workshop_id'], int):
            raise ModFieldInvalid(mod_name, 'workshop_id', 'must be an integer')

        workshop_id_str = str(mod_data['workshop_id'])
        if workshop_id_str in mod_workshop_ids:
            raise DuplicateModWorkshopID(mod_data['workshop_id'], mod_name, mod_workshop_ids[workshop_id_str])
        mod_workshop_ids[workshop_id_str] = mod_name

        filename = mod_data['filename']
        if filename in mod_filenames:
            raise DuplicateModPath(mod_name, mod_filenames[filename], filename)
        mod_filenames[filename] = mod_name

        if 'manual_install' in mod_data and not isinstance(mod_data['manual_install'], bool):
            raise ModFieldInvalid(mod_name, 'manual_install', 'must be a boolean')
        if 'kind' in mod_data and not isinstance(mod_data['kind'], str):
            raise ModFieldInvalid(mod_name, 'kind', 'must be a string')

        # Validate kind if present
        kind_str = mod_data.get('kind', Kind.MOD)
        try:
            kind = Kind(kind_str)
        except ValueError as e:
            raise ModInvalidKind(mod_name, kind_str, list(Kind)) from e

        if kind == Kind.SERVER_MOD:
            directory = Path(defaults['server_mod_directory'])
            if 'server_mod_directory' in mod_data:
                if not isinstance(mod_data['server_mod_directory'], str):
                    raise ModFieldInvalid(mod_name, 'server_mod_directory', 'must be a string')
                directory = Path(mod_data['server_mod_directory'])
        else:
            directory = Path(defaults['mod_directory'])
            if 'mod_directory' in mod_data:
                if not isinstance(mod_data['mod_directory'], str):
                    raise ModFieldInvalid(mod_name, 'mod_directory', 'must be a string')
                directory = Path(mod_data['mod_directory'])

        mod = Mod(
            filename=mod_data['filename'],
            workshop_id=str(mod_data['workshop_id']),
            kind=kind,
            directory=directory,
            manual_install=mod_data.get('manual_install', False),
            name=mod_name,
        )
        MODS[mod_name] = mod
        mods_added[mod_name] = mod

    async def update_mod_details():
        if mods_added:
            logger.info('Fetching mod details from Steam Workshop')
            details: dict[WorkshopId, Mod] = await fetch_mod_details_from_workshop(mods_added.values())
        else:
            logger.info('No mods to fetch details for')
            return

        for mod_name, mod in mods_added.items():
            detail = details.get(mod_name)
            mod.name = detail.title if detail else mod.name

    asyncio.run(update_mod_details())


class Kind(StrEnum):
    MOD = 'mod'
    SERVER_MOD = 'server_mod'


@dataclass
class Mod:
    directory: Path = Path('')
    name: str = ''
    filename: str = ''
    workshop_id: WorkshopId | None = None
    manual_install: bool = False
    kind: Kind = Kind.MOD

    def as_launch_parameter(self) -> str:
        """
        ### Generate launch parameter string for the mod

        *Docstring generated by AI.*

        Creates the command-line parameter format used when launching Arma 3 with this mod.
        Prefixes the filename with '@' symbol following Arma 3 mod parameter conventions.

        **Async:** No

        **Returns:**
        - `str`: The mod launch parameter in format '@filename'.

        **Example:**
        ```python
        mod = Mod(filename='ace')
        param = mod.as_launch_parameter()
        # '@ace'
        ```
        """
        return f'@{self.filename}'

    def path(self) -> Path:
        """
        ### Get the full filesystem path to the mod directory

        *Docstring generated by AI.*

        Combines the mod's base directory with its launch parameter to create the full
        path where the mod is installed. This is typically used to locate mod files
        on the filesystem.

        **Async:** No

        **Returns:**
        - `Path`: The complete path to the mod directory.

        **Example:**
        ```python
        mod = Mod(directory=Path('/mods'), filename='ace')
        mod_path = mod.path()
        # Path('/mods/@ace')
        ```
        """
        return self.directory / self.as_launch_parameter()

    def as_html(self) -> str:
        """
        ### Generate HTML representation of the mod

        *Docstring generated by AI.*

        Creates an HTML representation of the mod by reading a template file and
        formatting it with the mod's name and workshop ID. Used for displaying
        mod information in web interfaces.

        **Async:** No

        **Returns:**
        - `str`: The HTML string representing this mod.

        **Example:**
        ```python
        mod = Mod(name='ACE3', workshop_id='463939057')
        html = mod.as_html()
        # '<div class="mod">...</div>'
        ```
        """
        with open(Path('static/templates/arma/mod.html')) as f:
            return f.read().format(
                mod_name=self.name,
                workshop_id=self.workshop_id,
            )


class Modlist:
    _name: str
    _mods: list[Mod]

    def __init__(self, name: str, file: Path):
        """
        ### Initialize a modlist from a file

        *Docstring generated by AI.*

        Creates a new Modlist instance by reading mod names from a text file. Each line
        in the file should contain the name of a mod that exists in the global MODS
        dictionary. Registers the modlist in the global MODLISTS dictionary for later access.

        **Async:** No

        **Args:**
        - `name` (`str`): The name to assign to this modlist.
        - `file` (`Path`): The path to the text file containing mod names, one per line.

        **Raises:**
        - `ModNotDefined`: If a mod name in the file is not found in the global MODS dictionary.

        **Returns:**
        - `None`: This is a constructor that initializes the instance.

        **Example:**
        ```python
        modlist = Modlist('main_mods', Path('config/main.txt'))
        # Modlist instance created and registered in MODLISTS['main_mods']
        ```
        """
        self._name = name
        self._mods = []
        with open(file) as f:
            for mod in f:
                mod = mod.strip()
                if mod not in MODS:
                    raise ModNotDefined(mod)
                self._mods.append(MODS[mod])

        MODLISTS[self._name] = self

    @property
    def mods(self) -> list[Mod]:
        """
        ### Get the list of mods in this modlist

        *Docstring generated by AI.*

        Returns the list of Mod objects that are included in this modlist. This is
        a read-only property that provides access to the internal mod list.

        **Async:** No

        **Returns:**
        - `list[Mod]`: The list of Mod objects in this modlist.

        **Example:**
        ```python
        modlist = Modlist('main_mods', Path('config/main.txt'))
        mods = modlist.mods
        # [Mod(...), Mod(...), ...]
        ```
        """
        return self._mods

    def as_html(self, preset_name: str | None = None) -> str:
        """
        ### Generate HTML representation of the modlist

        *Docstring generated by AI.*

        Creates an HTML representation of the entire modlist by combining CSS styles
        with individual mod HTML representations. Uses template files to format the
        output for web display.

        **Async:** No

        **Args:**
        - `preset_name` (`str | None`): Optional override name for the modlist display. If None, uses the modlist's name.

        **Returns:**
        - `str`: The complete HTML string representing this modlist.

        **Example:**
        ```python
        modlist = Modlist('main_mods', Path('config/main.txt'))
        html = modlist.as_html('Custom Preset Name')
        # '<html><head><style>...</style></head><body>...</body></html>'
        ```
        """
        with open(Path('static/templates/arma/style.css')) as f:
            style = f.read()
        mod_html = ''.join(mod.as_html() for mod in self._mods)
        with open(Path('static/templates/arma/modlist.html')) as f:
            return f.read().format(
                style=style,
                modlist_name=self._name if preset_name is None else preset_name,
                html_mods=mod_html,
            )

    def has_mods_from(self, other: Self | Iterable[Mod]) -> bool:
        """
        ### Check if this modlist contains any mods from another modlist

        *Docstring generated by AI.*

        Determines whether this modlist shares any mods with another modlist by checking
        if any mod objects from the other modlist are present in this modlist. Used to
        identify server dependencies when updating mods.

        **Async:** No

        **Args:**
        - `other` (`Modlist`): The other modlist to compare against.

        **Returns:**
        - `bool`: True if this modlist contains any mods from the other modlist, False otherwise.

        **Example:**
        ```python
        modlist1 = Modlist('server1_mods', Path('config/server1.txt'))
        modlist2 = Modlist('server2_mods', Path('config/server2.txt'))
        has_shared = modlist1.has_mods_from(modlist2)
        # True or False
        ```
        """
        if isinstance(other, Modlist):
            mods = other.mods
        elif isinstance(other, Iterable):
            mods = list(other)
        else:
            raise TypeError(f'Expected Modlist or Iterable[Mod], got {type(other).__name__}')
        return any(mod in self._mods for mod in mods)
